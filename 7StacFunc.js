/* eslint-disable no-console */
/* eslint-disable max-len */

// 7.Задача о коллекции функций: у вас есть массив функций, напишите код, который вызовет каждую функцию в этом массиве и выведет их порядковый номер.
// Однако, вызов каждой функции должен происходить только после вызова предыдущей функции.
// Другими словами, нужно выполнить следующие шаги:
// Вызвать первую функцию из массива.
// После завершения работы первой функции вызвать вторую функцию.
// После завершения работы второй функции вызвать третью функцию.
// И так далее, пока все функции в массиве не будут вызваны по порядку.

//! Первый способ решения
const functions = [ //! Массив функций
  () => console.log('Первый способ', 1),
  () => console.log('Первый способ', 2),
  () => console.log('Первый способ', 3),
  // добавьте остальные функции в массив
];

//!
const callNextFunction = (index) => { //! Создаём переменую и записываем в неё рекурсивную функцию принимаем индекс массива который вызовем
  // проверка на выход за границы массива
  if (index >= functions.length) { //! Проверка если индекс равен или больше длины массивы функций вернём undefiend так как означает что мы прошли по всему массиву
    return; //! вернёт undefiend так как ничего не передано
  }

  const currentFunction = functions[index]; //! Записываем в переменную вызов функции под переданным индексом

  // вызов текущей функции
  currentFunction(); //! вызываем функцию

  // выполнение следующей функции после завершения текущей
  setTimeout(() => { //! Использую сетТаймаут для поочерёдного вызова функцию
    callNextFunction(index + 1); //! Так как функцию с переданным индексом была вызвана вызываем функцию следующую функцию после окончания выполнения текущей
  }, 0); //! 0 Миллисекунд для задержки вызова следующей функцию после окончания выполнения текущей
};

//! Вызываем функцию и передаём в неё аргумент с индексом массива в нашем случае 0 первый элемент массива
callNextFunction(0);

//! Второй способо решения
const functions2 = [ //! Массив функций
  () => console.log('Второй способ', 1),
  () => console.log('Второй способ', 2),
  () => console.log('Второй способ', 3),
  () => console.log('Второй способ', 4),
];

const callFunctions = (index) => { //! Создаём переменую и записываем в неё рекурсивную функцию принимаем индекс массива который вызовем
  if (index >= functions2.length) { //! Проверка если индекс равен или больше длины массивы функций вернём undefiend так как означает что мы прошли по всему массиву
    return; // Базовый случай: все функции вызваны //! вернёт undefiend так как ничего не передано
  }

  const currentFunction = functions2[index]; //! Записываем в переменную вызов функции под переданным индексом
  currentFunction(); //! Вызываем текущую функцию
  callFunctions(index + 1); //! Рекурсивно вызываем следующую функцию
};

callFunctions(0); //! Начинаем вызывать функции с индекса 0

//! Третий способ при помощи промисификации 

function delay(ms) { //! объявляем функцию делей которая возвращает промис, который резолвится через указанное время ms
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function runFunctionsInOrder(functions) { //! Функция принимает в себя в качетсве аргументов массив функций
  for(let i = 0; i < functions.length; i++) { //! используем цикл чтобы вызвать каждую функцию пока длина массива не закончится
    await functions[i](); //! Вызов текущей функции

    //! Задержка перед вызовом следующей функции
    await delay(1000);

    console.log(`Выполнена функция ${i+1}`);
  }
}

//! Пример использования
const functions3 = [
  async function() {
    console.log('Функция 1');
  },
  async function() {
    console.log('Функция 2');
  },
  async function() {
    console.log('Функция 3');
  },
  async function() {
    console.log('Функция 3');
  },
];

runFunctionsInOrder(functions3);
